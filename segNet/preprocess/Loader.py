import numpy as np
import scipy.ndimage
from pyquaternion import Quaternion
import math
from matplotlib import pyplot as plt

from math import *
from utils import *

np.set_printoptions(precision=4,suppress=True,linewidth=300)

h = 240
w = 320

def load_2m(top_dir):
  tmp = np.load(top_dir)['labeling'] 
  return tmp

def load_seg(filepath):
  try:
    seg = np.load(filepath)['labeling']
    seg[:,:,2] *= -1.0
  except:
    print(filepath)
    print('sth is wrong!')
    return np.zeros((h,w,3))
  return seg

def load_r(filepath,secondmoment_file,secondmoment=True):
   height = h
   width = w
   dist_image = np.zeros((height,width,1))
   seg = np.load(filepath)['labeling']
   if secondmoment:
     _2m = load_2m(secondmoment_file) * 50.0
     feature_map = np.concatenate((seg,_2m),axis=2)
     feature_map = feature_map.reshape((-1,6+3))
     idx_c = np.unique(feature_map,axis=0)
   else:
     d2_image = np.reshape(seg,(-1,3))
     idx_c = np.unique(d2_image,axis=0)
   idx_c = [idx_c[i] for i in xrange(len(idx_c)) if idx_c[i][0] != 0.0 and idx_c[i][1] != 0.0 and idx_c[i][2] != 0.0]
   d2_list = [i for i in xrange(len(idx_c))]
   if len(idx_c) == 1:
     dist_image = np.zeros((height,width,1))
   else:
     for i_c in xrange(len(idx_c)):
       dist = np.min(np.array([np.linalg.norm(idx_c[i_c] - idx_c[i]) for i in d2_list if i != i_c]))
       print(dist)
       dist_image[seg[:,:,2] == idx_c[i_c][2]] = dist / 10
   return dist_image
 
def load_xyz(filename):
    """Return image data from a PGM file generated by blensor. """
    fx = 472.92840576171875
    fy = fx 
    with open(filename, 'rb') as f:
        f.readline()
        f.readline()
        width_height = f.readline().strip().split()
        if len(width_height) > 1:
          width, height = map(int,width_height)
          value_max_range = float(f.readline())
          image_ = [float(line.strip()) for line in f.readlines()]
          if len(image_) == height * width:
            nx,ny = (width,height)
            x_index = np.linspace(0,width-1,width)
            y_index = np.linspace(0,height-1,height)
            xx,yy = np.meshgrid(x_index,y_index)
            xx -= float(width)/2
            yy -= float(height)/2
            xx /= fx
            yy /= fy

            cam_z = np.reshape(image_,(height, width))
            cam_z = cam_z / value_max_range * 1.5
            cam_x = xx * cam_z 
            cam_y = yy * cam_z
            image_z = np.flipud(cam_z)
            image_y = np.flipud(cam_y)
            image_x = np.flipud(cam_x)

            zoom_scale = 0.5
            image_x = scipy.ndimage.zoom(image_x, zoom_scale, order=1)
            image_y = scipy.ndimage.zoom(image_y, zoom_scale, order=1)
            image_z = scipy.ndimage.zoom(image_z, zoom_scale, order=1)
            image = np.dstack((image_x,image_y,image_z))
            return image
    return np.zeros((h,w,3))


def load_score(inputfilename,gtfilename):
  xyz = load_xyz(inputfilename)[:,:,0:2]
  seg = load_seg(gtfilename)[:,:,0:2]
  score = np.zeros((h,w))
  score_tmp = score.reshape((-1,1))
  xyz_tmp = xyz.reshape((-1,2)) 
  seg_tmp = seg.reshape((-1,2)) 
  idx_c = np.unique(seg_tmp,axis=0) 
  diff = xyz_tmp - seg_tmp
  diff_norm = np.linalg.norm(diff,axis=1)    
  for idx in idx_c:
    if idx[0] != 0.0:
      tmp = np.where(seg_tmp == idx)[0]
      dist = diff_norm[tmp] 
      top_k = min(len(dist),300)
      tmp_indx = dist.argsort()[:top_k]
      index = tmp[tmp_indx]
      score_tmp[index] = 1.0 
    else:  
      print(idx)
  score = score_tmp.reshape((h,w)) 
  return score

if __name__ == '__main__':
  top_dir = '/home/lins/interactive-segmentation/Data/BlensorResult_2frame/20/frame80_2moment.npz'
  load_secondmoment(top_dir)
